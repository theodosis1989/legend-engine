import meta::external::store::document::tests::object::*;
import meta::nonRelational::functions::pureToNoSqlQuery::*;
import meta::external::store::document::metamodel::*;
import meta::nonRelational::functions::noSqlQueryToString::default::*;

function <<test.Test>> meta::nonRelational::functions::test::getAllPropertiesWhenMappingHasAllTheCollectionFields():Boolean[1]
{
  let documentAndStoreMapping = meta::external::store::document::tests::object::getDocumentStoreAndMapping();
  let collection = meta::external::store::document::tests::object::getCollection();
  let state = meta::external::store::document::tests::object::getState();

  let properties = meta::nonRelational::functions::pureToNoSqlQuery::processNoRelationalMappingSpecification($documentAndStoreMapping.second, $state, $collection);

  let allFields = meta::external::store::document::tests::object::getAllFields();

  assertEquals($properties.fields->size(), 3);
  assertEquals($properties.fields->at(0).name, $allFields->at(0).name);
  assertEquals($properties.fields->at(1).name, $allFields->at(1).name);
  assertEquals($properties.fields->at(2).name, $allFields->at(2).name);
}

function <<test.Test>> meta::nonRelational::functions::test::getOnlyPropertiesThatAreStillInTheCollection():Boolean[1]
{
  let documentAndStoreMapping = meta::external::store::document::tests::object::getDocumentStoreAndMapping();
  let collection = meta::external::store::document::tests::object::getCollectionWithLessFieldsThanMapping();
  let state = meta::external::store::document::tests::object::getState();

  let properties = meta::nonRelational::functions::pureToNoSqlQuery::processNoRelationalMappingSpecification($documentAndStoreMapping.second, $state, $collection);

  let allFields = meta::external::store::document::tests::object::getAllFields();

  assertEquals($properties.fields->size(), 2);
  assertEquals($properties.fields->at(0).name, $allFields->at(0).name);
  assertEquals($properties.fields->at(1).name, $allFields->at(1).name);
}

function <<test.Test>> meta::nonRelational::functions::test::buildMongoQueryForAllFields():Boolean[1]
{
  let collection = meta::external::store::document::tests::object::getCollection();
  let fields = meta::external::store::document::tests::object::getAllFields();
  
  let documetQuery = ^DocumentQuery(
    collection=$collection,
    fields=$fields
  );

  let actualMongoQuery = meta::nonRelational::functions::noSqlQueryToString::default::processDocumentQuery($documetQuery);
  let expectedMongoQuery = '{"aggregate":"personDocument", "pipeline":[{ "$match":{}, { "$project": { "fName": 1 ,"lName": 1 ,"oNames": 1 } }]';
  
  assertEquals($actualMongoQuery, $expectedMongoQuery);
}

function <<test.Test>> meta::nonRelational::functions::test::buildMongoQueryForOnlyTwoFields():Boolean[1]
{
  let collection = meta::external::store::document::tests::object::getCollection();
  let fields = meta::external::store::document::tests::object::getAllFields();
  
  let documetQuery = ^DocumentQuery(
    collection=$collection,
    fields=[$fields->at(0),$fields->at(1)]
  );

  let actualMongoQuery = meta::nonRelational::functions::noSqlQueryToString::default::processDocumentQuery($documetQuery);
  let expectedMongoQuery = '{"aggregate":"personDocument", "pipeline":[{ "$match":{}, { "$project": { "fName": 1 ,"lName": 1 } }]';
  
  assertEquals($actualMongoQuery, $expectedMongoQuery);
}


function <<test.Test>> meta::nonRelational::functions::test::buildFilter():Boolean[1]
{
  let allFields = meta::external::store::document::tests::object::getAllFields();
  let mongoStore = meta::external::store::document::tests::object::getMongoStore();
  let literal = ^Literal(
    id='literal',
    owner=$mongoStore,
    name='literal',
    value='My first name'
  );

  let dynaFunction = ^DynaFunction(
    id='dynaFunction',
    owner=$mongoStore,
    name='equal',
    parameters=[$allFields->at(0), $literal]
  );

  let actualOutput = meta::nonRelational::functions::noSqlQueryToString::processDynaFunction($dynaFunction);

  let expectedOutput = '{ "fName": { "$eq": "My first name" } }'; 

  assertEquals($actualOutput, $expectedOutput);
}

function <<test.Test>> meta::nonRelational::functions::test::buildCompositeFilter():Boolean[1]
{
  let allFields = meta::external::store::document::tests::object::getAllFields();
  let mongoStore = meta::external::store::document::tests::object::getMongoStore();
  let literal1 = ^Literal(
    id='literal',
    owner=$mongoStore,
    name='literal',
    value='My first name'
  );

  let literal2 = ^Literal(
    id='literal',
    owner=$mongoStore,
    name='literal',
    value='My last name'
  );

  let dynaFunctionEqual1 = ^DynaFunction(
    id='dynaFunction',
    owner=$mongoStore,
    name='equal',
    parameters=[$allFields->at(0), $literal1]
  );

  let dynaFunctionEqual2 = ^DynaFunction(
    id='dynaFunction',
    owner=$mongoStore,
    name='equal',
    parameters=[$allFields->at(1), $literal2]
  );

  let dynaFunctionAnd = ^DynaFunction(
    id='dynaFunction',
    owner=$mongoStore,
    name='and',
    parameters=[$dynaFunctionEqual1, $dynaFunctionEqual2]
  );

  let dynaFunctionGroup = ^DynaFunction(
    id='dynaFunction',
    owner=$mongoStore,
    name='group',
    parameters=[$dynaFunctionAnd]
  );

  let actualOutput = meta::nonRelational::functions::noSqlQueryToString::processDynaFunction($dynaFunctionGroup);

  let expectedOutput = '{ "$and": [{ "fName": { "$eq": "My first name" } }, { "lName": { "$eq": "My last name" } }] }'; 

  assertEquals($actualOutput, $expectedOutput);
}