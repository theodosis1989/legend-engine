import meta::external::store::document::metamodel::*;
import meta::external::shared::format::binding::*;
import meta::nonRelational::functions::pureToNoSqlQuery::*;
import meta::external::store::document::metamodel::mapping::*;
import meta::nonRelational::functions::noSqlQueryToString::*;
import meta::nonRelational::functions::noSqlQueryToString::default::*;


// should go in a different file
function <<access.private>> meta::nonRelational::functions::pureToNoSqlQuery::processFieldsInNoRelationalOperationElements(fields: DocumentStoreElement[*], collection: Collection[1]): DocumentQuery[*]
{
    let fieldNames = $fields->map(f| $f.name); // it can be done more efficiently with a set instead of an array.
    let activeFields = $collection.fields->filter(c| $c.name->in($fieldNames));
    ^DocumentQuery(
      fields=$activeFields,
      collection=$collection
    );
}

// should go in a different file
function <<access.private>> meta::nonRelational::functions::pureToNoSqlQuery::fieldNamesWithNoRelationalElement(r: RootDocumentInstanceSetImplementation[1], state: State[1]): Pair<String, DocumentStoreElement>[*]
{
  $r.propertyMappings
    ->filter(x | if($state.graphFetchFlow == true, | $x.property->in($state.graphFetchProperties), | true))
    ->map(pm|pair($pm.property.name->toOne(),$pm->cast(@DocumentPropertyMapping).documentStoreElement))
}

// should go in a different file
function meta::nonRelational::functions::pureToNoSqlQuery::processNoRelationalMappingSpecification(r: RootDocumentInstanceSetImplementation[1], state: State[1], collection: Collection[1]): DocumentQuery[*]
{
  let pairsMappingNameToField = meta::nonRelational::functions::pureToNoSqlQuery::fieldNamesWithNoRelationalElement($r, $state);
  meta::nonRelational::functions::pureToNoSqlQuery::processFieldsInNoRelationalOperationElements($pairsMappingNameToField.second, $collection);
}

function meta::nonRelational::functions::noSqlQueryToString::processDynaFunction(d: DynaFunction[1]): String[1]
{
  let name = $d.name;
  let parameters = $d.parameters;

// add all operations, greater than, lower than, etc
  if ($name == 'equal' || $name == 'not equal',
    | let operationSymbol = getOperationSymbol($name);
      let key = $parameters->at(0)->cast(@Field).name;
      let value = $parameters->at(1)->cast(@Literal).value;
      '{ "' + $key + '": { "' + $operationSymbol + '": "' + $value + '" } }';
    ,
    | if ($name == 'and' || $name == 'or',
      | let andOr = $parameters->fold({item, acc | $acc->concatenate(processDynaFunction($item->cast(@DynaFunction)))}, []);
        '{ "$' + $name + '": [' + $andOr->joinStrings(', ') + '] }';
      ,
      | processDynaFunction($parameters->at(0)->cast(@DynaFunction)); // this "else" here assumes that the name of the dynaFunction is "group". Is there something else to consider?
      )
    );
}

function <<access.private>> meta::nonRelational::functions::noSqlQueryToString::getOperationSymbol(op:String[1]): String[1]
{
  // add all operations, greater than, lower than, etc
  if ($op == 'equal', | '$eq', | '$eq')
}

function meta::nonRelational::functions::noSqlQueryToString::default::processDocumentQuery(dq:DocumentQuery[1]): String[1]
{
  '{"aggregate":"' + $dq.collection.name + '", "pipeline":' + processPipelines($dq)
}

function <<access.private>> meta::nonRelational::functions::noSqlQueryToString::default::processPipelines(dq:DocumentQuery[1]): String[1]
{
  '[' + processMatch($dq) + ', ' + processProject($dq) + ']'
}

function <<access.private>> meta::nonRelational::functions::noSqlQueryToString::default::processMatch(dq:DocumentQuery[1]): String[1]
{
  if(true,| '{' + '"$match":{}', | '"$match":{"a map here to get the items"}');
}

function <<access.private>> meta::nonRelational::functions::noSqlQueryToString::default::processProject(dq:DocumentQuery[1]): String[1]
{
  '{ "$project": { ' + $dq.fields->map(f | '"' + $f.name + '": 1 ')->joinStrings(',') + '} }';
}